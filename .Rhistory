####Popolazione italiana####
fecondita <- read_delim("Fecondita-totale-2000-2021.csv",
delim = ";", escape_double = FALSE, trim_ws = TRUE)
####Popolazione italiana####
library(readR)
####Popolazione italiana####
library(readr)
fecondita <- read_delim("Fecondita-totale-2000-2021.csv",
delim = ";", escape_double = FALSE, trim_ws = TRUE)
years <- 2000:2021
eta <- 17:50
fac <- matrix(rep(0, length(years)*length(eta)), nrow = length(years), ncol = length(eta))
a <- 1
for (j in 1:length(eta))
{
for (i in 1:length(years))
{
fac[i,j] <- fecondita$Value[a]
a <- a+1
}
}
colnames(fac) <- eta
row.names(fac) <- years
x11()
matplot(t(fac), type='l', col=1:length(years))
####Proviamo l'approccio functional e vediamo che succede - smoothing####
library(fda)
abscissa <- 1:length(eta)
observations <- t(fac)
orders <- 2:6
gcv <- matrix(rep(0, length(orders)*length(abscissa)), nrow = length(orders), ncol = (length(abscissa)))
row.names(gcv) <- orders
colnames(gcv) <- abscissa
for (m in orders)
{
grid <- (m+1):(length(abscissa)-1)
for (i in grid)
{
basis <- create.bspline.basis(rangeval=range(abscissa), nbasis=i, norder = m)
functionalPar <- fdPar(fdobj=basis)
for (j in 1:length(years))
{ gcv[m-1, i] <- gcv[m-1, i] + smooth.basis(1:34, observations[, j], functionalPar)$gcv}
}
}
View(gcv)
min <- min(gcv[-which(gcv==0)])
which(gcv == min, arr.ind=TRUE)
basis <- create.bspline.basis(rangeval=range(abscissa), nbasis=10, norder = 2)
basismat <- eval.basis(abscissa, basis)
est_coef = lsfit(basismat, observations, intercept=FALSE)$coef
Xsp0 <- basismat %*% est_coef
matplot(Xsp0, type='l')
View(fecondita)
fecondita <- read_delim("Fecondita-totale-2000-2021.csv",
delim = ",", escape_double = FALSE, trim_ws = TRUE)
View(fecondita)
